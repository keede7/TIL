## 동시성 문제

#### Race Condition

**둘 이상의 쓰레드**가 공유 데이터에 접근할 수 있고 동시에 변경하려고 할 때 발생하는 문제를 말한다.


### Application Level Solution ( Java ) 

1. `Synchronized` 
`Java` 에서 `Application level` 에서 해결할 수 있는 방법이다. `메서드` 또는 `변수`에 걸 수 있고, 

해당 예약어가 걸려있는 데이터는 **하나의 쓰레드만**이 접근 할 수 있게 된다.


**Synchronized 문제점**

1. `트랜잭션`을 걸었을 경우 `트랜잭션`의 동작방식에 의해서 정합성을 맞추는 과정에 (`Commit`) 다른 쓰레드의 접근을 허용하므로 문제가 있음.
( 정확하게는 트랜잭션의 실제 동작 과정을 이해하면 쉽게 알 수 있다 )

2. **하나의 프로세스** 안에서만 보장하기 떄문에 서버를 여러대 운용하는 실무에서의 경우 사용하기 어려운 방식이다.

---

### DataBase Solution

1) `Pessimistic Lock` - 비관적 락

서버가 여러 대 있을 때 특정 서버가 DB의 데이터에 `Lock`을 거는 방법이며 해당 서버가 `Lock`을 해제하기 전까지 데이터를 가져갈 수 없다.

- 장점
  - 충돌이 빈번하게 일어나는 환경이라면 `Optimistic Lock` 보다 성능이 좋을 수 있다
  - `Lock`을 통해 데이터를 제어하기 떄문에 **정합성**이 어느정도 보장된다.

- 단점
  - 별도의 `Lock`을 잡기 떄문에 성능 감소가 있을 수 있다.


2) `Optimistic Lock` - 낙관적 락

실제 `Lock`을 사용하는 방법이 아니라 `Version`을 이용한 방식이다. 

DB를 읽고 업데이트를 할 때 `Version` 값을 같이 전달해서 현재 `Version`이 맞는지 확인하고 틀리다면 

해당 쓰레드의 요청은 다시 애플리케이션에서 데이터를 읽고 쿼리를 수행해야 한다. ( **재시도 로직을 직접 개발자가 작성해줘야 한다** )

- 장점
  - 별도의 Lock을 잡지 않기 때문에 Pessimistic Lock 보다 성능상 이점이 있다.

- 단점
  - 업데이트가 실패하면 재시도 하는 로직을 개발자가 직접 작성해야한다.



### 충돌이 빈번하다고 예상하면 Pessimistic Lock, 그게 아니라면 Optimistic Lock을 쓰는게 성능상 이점이 있을 수 있다.



3) `Named Lock`
**이름을 가진 `Metadata Lock`** 이다. **이름을 가진 `Lock`** 을 획득하고 해제하기 전 까지 다른 세션이 `Lock`을 획득할 수 없게한다.

주의점으로 트랜잭션이 종료될 떄 `Lock`이 **자동으로 해제되지 않으므로** **별도의 명령어로 해제하거나, 선점시간이 끝나야 해결된다.**

실제로 쓸때는 `DataSource`를 분리해서 사용해야 하는데, 같은걸 쓰면 `커넥션 풀`이 부족해져서 다른서비스에 영향을 미칠 수 있기 때문이다.

그래서 실무에서는 분리해서 쓰는걸 추천한다.


`Named Lock`은 주로 `분산 락`을 구현할 때 쓴다. `Pessimistic Lock`은 `TimeOut`을 구현하기 힘들지만 `Named Lock`은 손쉽게 구현할 수 있다.

이외에 추가시 `정합성`을 맞춰야하는 경우에도 사용할 수 있다. 

하지만, 트랜잭션 종료시 `Lock 해제`와 `세션관리`를 잘 해줘야해서 주의해서 사용해야하고 **실제로 쓸때는 구현방법이 복잡할 수 있다.** 
 
 ---
 
### Redis Solution 

주로 `분산 락`을 구현할 때 쓰는 방법이다. 대표적인 라이브러리로 `Lettuce` 와 `Redisson` 이 있다.

1) `Lettuce`

`setnx` 명령어를 사용해서 `분산 락`을 구현 할 수 있다. `Key` 와 `Value` 를 `set` 할 때 기존 값이 없을 때만 `set` 을 수행한다.

`Lettuce` 는 `spin lock` 방식인데, **개발자가 직접 재시도 로직을 작성**해줘야 한다. ( == `Optimistic Lock` )


* `Spin Lock` - `Lock` 을 획득하려는 쓰레드가 획득이 가능한지 반복적으로 확인해서 `Lock` 획득 시도를 하는 방식.


`setnx` 가 데이터가 있으면 실패를 리턴하기 떄문에, `spin lock`에 의해서 자동적으로 반복해서 `Lock` 을 획득하려는 시도를

하기 떄문에 실제 구현 로직에서 재시도하는 시간의 공백을 주는 형식으로 작성해야 한다.


2) `Redisson`

`pub-sub` 기반으로 `Lock` 이 구성되어 있다. `pub-sub` 기반은 중간 채널을 하나 생성하고, `Lock` 을 점유하고 있는 쓰레드가

채널에 `Lock` 해제 메세지를 알려주면 채널에서 `Lock` 을 획득하려고 대기중인 쓰레드에게 안내메세지를 보내고 그 때 쓰레드가 `Lock` 획득시도를 하는 방식이다.

**이 방식은 `Lettuce` 와 다르게 재시도 로직을 따로 작성하지 않아도 된다.**

`Redisson` 은 `Lettuce` 에 비해서 `Lock` 해제 메세지를 받고나서 `Lock` 획득 시도를 최대1번 까지만 할 수 있어서

`Redis` 의 부하가 상대적으로 적다.

그리고, 따로 `Lock` 관련 클래스를 제공하기 떄문에 `Repository` 를 따로 작성하지 않아도 된다.

대신, 로직 실행 전 후로 `Lock` 획득 해제는 해줘야 한다.


### Redis 방식의 비교


- `Lettuce`
  - 구현이 간단하다는 장점이 있다.
  - `Spring Data Redis` 를 추가하면 `Lettuce` 가 기본 라이브러리 이므로 별도 라이브러리를 추가 할 필요가 없다.
  - `Spin Lock` 방식이므로 많은 쓰레드가 동시에 `Lock` 획득 대기 상태면 지속적인 부하가 발생할 수 있다.

- `Redisson`
  - `Lock` 획득 재시도를 기본으로 제공한다.
  - `pub-sub` 구성이므로 `Redis`에 비교적 부하가 덜 간다.
  - 대신, 별도의 라이브러리를 추가해서 써야한다.
  - `Lock` 을 라이브러리 차원에서 제공하기 떄문에 사용법을 익혀야 한다는 단점이 있다.

#### Redis 방식 결론

- 실무에서 재시도가 필요하지 않다 == `Lettuce`
- 재시도가 필요하다면 `Redisson` 을 혼용한다.

---

### DB (MySQL) vs Redis

- `MySQL` 
  - 이미 쓰고 있는 경우라면 별도의 비용없이 사용가능하다는 장점이 있다.
  - 성능이 `Redis` 보다 낫진 않지만, 어느정도의 트래픽은 문제 없이 사용가능하다.

- `Redis`
  - `Redis` 를 활용중이지 않다면 **별도의 구축비용**과 **인프라 관리 비용**이 추가로 들어간다.
  - 대신 `MySQL` 보다 성능이 좋아서 더 많은 트래픽을 처리할 수 있다.

#### 결론

- 실무에서 비용적 여유가 없거나 트래픽이 적은 수준이다 == `MySQL`
- 그게 아니라면 `Redis`






















